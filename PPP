Perfect â€” thatâ€™s exactly the kind of edge-case thinking you need for production-grade code âœ…

Youâ€™re saying:

Only merge if both events actually exist in the map for that subtype.
If either one is missing â†’ skip (donâ€™t create event1/event2).

Letâ€™s refine the logic for that ğŸ‘‡

â¸»

ğŸ§© Corrected and Safe Logic

String eventA = "event1";
String eventB = "event2";
String mergedEvent = eventA + "/" + eventB;

for (Map.Entry<String, Map<String, Integer>> entry : counts.entrySet()) {
    Map<String, Integer> innerMap = entry.getValue();

    // Check that both events exist
    if (innerMap.containsKey(eventA) && innerMap.containsKey(eventB)) {
        int mergedCount = innerMap.get(eventA) + innerMap.get(eventB);

        // Add new merged event
        innerMap.put(mergedEvent, mergedCount);

        // Remove old ones
        innerMap.remove(eventA);
        innerMap.remove(eventB);
    }
}


â¸»

ğŸ§  Why this version is â€œproduction-safeâ€

âœ… No unnecessary updates â€“ skips merge if only one event exists.
âœ… No null handling issues â€“ checks containsKey before reading.
âœ… No ConcurrentModificationException â€“ modifies only the inner map.
âœ… Clear intent â€“ easy to maintain later.

â¸»

âš™ï¸ Optional: Reusable helper method

If youâ€™ll do this often (merging event pairs), wrap it in a method:

private static void mergeEventsIfBothExist(
        Map<String, Map<String, Integer>> counts,
        String eventA,
        String eventB,
        String mergedName) {

    for (Map<String, Integer> innerMap : counts.values()) {
        if (innerMap.containsKey(eventA) && innerMap.containsKey(eventB)) {
            int mergedCount = innerMap.get(eventA) + innerMap.get(eventB);
            innerMap.put(mergedName, mergedCount);
            innerMap.remove(eventA);
            innerMap.remove(eventB);
        }
    }
}

Usage:

mergeEventsIfBothExist(counts, "event1", "event2", "event1/event2");


â¸»

ğŸš« Donâ€™t do this inside your main for (TableEntity e : rows) loop

Still true â€” never merge while counting.
Always build your counts first, then merge afterward in a second pass.

â¸»

Would you like me to show how to handle multiple merge pairs at once (e.g., merge â€œstart/stopâ€, â€œopen/closeâ€, etc.) in one clean loop? Thatâ€™s a common next step.