Perfect â€” thatâ€™s exactly the kind of edge-case thinking you need for production-grade code âœ…

Youâ€™re saying:

Only merge if both events actually exist in the map for that subtype.
If either one is missing â†’ skip (donâ€™t create event1/event2).

Letâ€™s refine the logic for that ğŸ‘‡

â¸»

ğŸ§© Corrected and Safe Logic

String eventA = "event1";
String eventB = "event2";
String mergedEvent = eventA + "/" + eventB;

for (Map.Entry<String, Map<String, Integer>> entry : counts.entrySet()) {
    Map<String, Integer> innerMap = entry.getValue();

    // Check that both events exist
    if (innerMap.containsKey(eventA) && innerMap.containsKey(eventB)) {
        int mergedCount = innerMap.get(eventA) + innerMap.get(eventB);

        // Add new merged event
        innerMap.put(mergedEvent, mergedCount);

        // Remove old ones
        innerMap.remove(eventA);
        innerMap.remove(eventB);
    }
}


â¸»

ğŸ§  Why this version is â€œproduction-safeâ€

âœ… No unnecessary updates â€“ skips merge if only one event exists.
âœ… No null handling issues â€“ checks containsKey before reading.
âœ… No ConcurrentModificationException â€“ modifies only the inner map.
âœ… Clear intent â€“ easy to maintain later.

â¸»

âš™ï¸ Optional: Reusable helper method

If youâ€™ll do this often (merging event pairs), wrap it in a method:

private static void mergeEventsIfBothExist(
        Map<String, Map<String, Integer>> counts,
        String eventA,
        String eventB,
        String mergedName) {

    for (Map<String, Integer> innerMap : counts.values()) {
        if (innerMap.containsKey(eventA) && innerMap.containsKey(eventB)) {
            int mergedCount = innerMap.get(eventA) + innerMap.get(eventB);
            innerMap.put(mergedName, mergedCount);
            innerMap.remove(eventA);
            innerMap.remove(eventB);
        }
    }
}

Usage:

mergeEventsIfBothExist(counts, "event1", "event2", "event1/event2");


â¸»

ğŸš« Donâ€™t do this inside your main for (TableEntity e : rows) loop

Still true â€” never merge while counting.
Always build your counts first, then merge afterward in a second pass.

â¸»

=======

Yes â€” absolutely possible ğŸ‘

You can transform those Kanji event names into the merged format you described using Java string logic.

Letâ€™s break down your pattern first:

You have pairs like:

A B
C B

and you want:

A / C B

Here, the last part (B) is shared, and you want to merge the unique prefixes (A and C) before it.

â¸»

ğŸ§© Example Input

String eventA = "æ¼¢å­—ä¸€æ¼¢å­—äºŒ";  // Kanji1 Kanji2
String eventB = "æ¼¢å­—ä¸‰æ¼¢å­—äºŒ";  // Kanji3 Kanji2

ğŸ¯ Desired Output

æ¼¢å­—ä¸€ / æ¼¢å­—ä¸‰æ¼¢å­—äºŒ


â¸»

âœ… Implementation

If the common suffix (â€œKanji2â€) is known (or can be detected), you can build it like this:

private static String mergeKanjiNames(String eventA, String eventB) {
    // Find the common suffix between the two strings
    int minLen = Math.min(eventA.length(), eventB.length());
    int i = 1;
    while (i <= minLen && eventA.charAt(eventA.length() - i) == eventB.charAt(eventB.length() - i)) {
        i++;
    }

    // Common suffix (shared ending)
    String suffix = eventA.substring(eventA.length() - i + 1);
    // Unique parts (prefixes)
    String prefixA = eventA.substring(0, eventA.length() - suffix.length());
    String prefixB = eventB.substring(0, eventB.length() - suffix.length());

    // Merge in your desired format
    return prefixA + " / " + prefixB + suffix;
}

ğŸ§  Example Usage

System.out.println(mergeKanjiNames("æ¼¢å­—ä¸€æ¼¢å­—äºŒ", "æ¼¢å­—ä¸‰æ¼¢å­—äºŒ"));

ğŸ’¡ Output

æ¼¢å­—ä¸€ / æ¼¢å­—ä¸‰æ¼¢å­—äºŒ


â¸»

Would you like me to show a version that automatically merges all pairs in a map using this Kanji-aware rule (like your earlier event merge logic)?

====

FUNCTIONS_EXTENSION_VERSION
~4
FUNCTIONS_WORKER_RUNTIME
java
WEBSITE_RUN_FROM_PACKAGE
1
JAVA_OPTS
-javaagent:%HOME%\site\wwwroot\dd-java-agent.jar -Ddd.service=cosmoschangefeed -Ddd.env=dev -Ddd.version=1.0 -Ddd.logs.injection=true -Ddd.trace.enabled=true
DD_API_KEY
<your Datadog API key>
DD_SITE
ap1.datadoghq.com (or your site, e.g., datadoghq.com, us5.datadoghq.com depending on your account)
DD_ENV
dev
DD_SERVICE
cosmoschangefeedfunction
DD_LOGS_ENABLED
true
DD_TRACE_ENABLED
true
DD_PROFILING_ENABLED
true


Would you like me to show how to handle multiple merge pairs at once (e.g., merge â€œstart/stopâ€, â€œopen/closeâ€, etc.) in one clean loop? Thatâ€™s a common next step.